// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./DocumentRegistry.sol";

// Resolutions
import "./ZunResolution.sol";
import "./MyanganResolution.sol";
import "./TumenResolution.sol";
import "./ChairmanResolution.sol";

// Leader appointments
import "./ZunLeaderAppointment.sol";
import "./MyanganLeaderAppointment.sol";
import "./TumenLeaderAppointment.sol";
import "./ArbanLeaderAppointment.sol";

// Citizen-level join doc
import "./ArbanJoinDoc.sol";

/* ========= Interfaces ========= */

interface IStructureRegistryUpdaters {
    function setUpdater(address upd, bool ok) external;
}

interface IArbanRegistryJoinDocs {
    function setJoinDoc(address doc, bool ok) external;
}

interface IArbanRegistryUpdaters {
    function setUpdater(address upd, bool ok) external;
}

/* ========= NotaryHub ========= */

contract NotaryHub {
    enum NotaryGrade {
        NONE,
        CITIZEN,
        ZUN,
        MYANGAN,
        TUMEN,
        CHAIRMAN
    }

    address public owner;
    address public chairmanRegistry;

    DocumentRegistry public immutable docRegistry;
    address public immutable structureRegistry;

    mapping(address => NotaryGrade) public notaryGrade;
    mapping(address => bool) public active;

    // ====== EVENTS ======
    event OwnerSet(address indexed newOwner);
    event ChairmanRegistrySet(address indexed chairmanRegistry);
    event NotarySet(address indexed notary, NotaryGrade grade, bool active);

    // Citizen docs
    event ArbanJoinDocIssued(
        uint256 indexed docId,
        uint256 indexed arbanId,
        address indexed docAddress,
        address leader,
        uint256 minSignatures,
        bytes32 docHash
    );

    event ArbanLeaderAppointmentIssued(
        uint256 indexed docId,
        uint256 indexed arbanId,
        address indexed docAddress,
        address newLeaderCitizenAccount,
        uint256 minSignatures,
        bytes32 docHash
    );

    // Zun
    event ZunDocumentIssued(
        uint256 indexed docId,
        uint256 indexed zunId,
        address indexed docAddress,
        bytes32 docHash
    );

    event ZunLeaderAppointmentIssued(
        uint256 indexed docId,
        uint256 indexed zunId,
        address indexed docAddress,
        address newLeader,
        bytes32 docHash
    );

    // Myangan
    event MyanganDocumentIssued(
        uint256 indexed docId,
        uint256 indexed myanganId,
        address indexed docAddress,
        bytes32 docHash
    );

    event MyanganLeaderAppointmentIssued(
        uint256 indexed docId,
        uint256 indexed myanganId,
        address indexed docAddress,
        address newLeader,
        bytes32 docHash
    );

    // Tumen
    event TumenDocumentIssued(
        uint256 indexed docId,
        uint256 indexed tumenId,
        address indexed docAddress,
        bytes32 docHash
    );

    event TumenLeaderAppointmentIssued(
        uint256 indexed docId,
        uint256 indexed tumenId,
        address indexed docAddress,
        address newLeader,
        bytes32 docHash
    );

    // Chairman
    event ChairmanDocumentIssued(uint256 indexed docId, address indexed docAddress, bytes32 docHash);

    // ====== ERRORS ======
    error NotOwner();
    error NotActiveNotary();
    error WrongNotaryGrade();
    error ChairmanRegistryNotSet();
    error ZeroAddress();
    error InvalidCount();

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    constructor(address structureRegistry_, address docRegistry_, address chairmanRegistry_) {
        if (structureRegistry_ == address(0) || docRegistry_ == address(0)) revert ZeroAddress();

        owner = msg.sender;
        structureRegistry = structureRegistry_;
        docRegistry = DocumentRegistry(docRegistry_);
        chairmanRegistry = chairmanRegistry_;

        emit OwnerSet(msg.sender);
        emit ChairmanRegistrySet(chairmanRegistry_);
    }

    // ====== ADMIN ======
    function setOwner(address newOwner) external onlyOwner {
        if (newOwner == address(0)) revert ZeroAddress();
        owner = newOwner;
        emit OwnerSet(newOwner);
    }

    function setChairmanRegistry(address chairmanRegistry_) external onlyOwner {
        chairmanRegistry = chairmanRegistry_;
        emit ChairmanRegistrySet(chairmanRegistry_);
    }

    function setNotary(address notary, NotaryGrade grade, bool isActive) external onlyOwner {
        notaryGrade[notary] = grade;
        active[notary] = isActive;
        emit NotarySet(notary, grade, isActive);
    }

    /* =========================================================
       CITIZEN: ARBAN JOIN DOC
       ========================================================= */

    /**
     * IMPORTANT:
     * This assumes ArbanJoinDoc constructor signature is:
     * (uint256 arbanId, address leader, address arbanRegistry, address seatSbt, uint256[] memory seatIds, uint256 minSignatures, bytes32 docHash)
     */
    function issueArbanJoinDoc(
        address arbanRegistry,
        address seatSbt,
        uint256 arbanId,
        address leader,
        uint256[] calldata seatIds,
        uint256 minSignatures,
        bytes32 docHash
    ) external returns (uint256 docId, address docAddress) {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.CITIZEN) revert WrongNotaryGrade();

        if (arbanRegistry == address(0) || seatSbt == address(0) || leader == address(0)) revert ZeroAddress();

        uint256 n = seatIds.length;
        if (n < 2 || n > 10) revert InvalidCount();
        if (minSignatures < 2 || minSignatures > n) revert InvalidCount();

        ArbanJoinDoc doc = new ArbanJoinDoc(
            arbanId,
            leader,
            arbanRegistry,
            seatSbt,
            seatIds,
            minSignatures,
            docHash
        );

        docAddress = address(doc);

        // authorize join doc so finalize() can call ArbanRegistry.finalizeArbanJoin()
        IArbanRegistryJoinDocs(arbanRegistry).setJoinDoc(docAddress, true);

        docId = docRegistry.issue(
            DocumentRegistry.Grade.CITIZEN,
            arbanId,
            docHash,
            msg.sender,
            docAddress
        );

        emit ArbanJoinDocIssued(docId, arbanId, docAddress, leader, minSignatures, docHash);
    }

    /* =========================================================
       CITIZEN: ARBAN LEADER APPOINTMENT (CitizenRegistry enforced)
       ========================================================= */

    /**
     * This assumes patched ArbanLeaderAppointment constructor signature is:
     * (address arbanRegistry, address citizenRegistry, uint256 arbanId, address newLeaderCitizenAccount, uint256 minSignatures, bytes32 docHash)
     */
    function issueArbanLeaderAppointment(
        address arbanRegistry,
        address citizenRegistry,
        uint256 arbanId,
        address newLeaderCitizenAccount,
        uint256 minSignatures,
        bytes32 docHash
    ) external returns (uint256 docId, address docAddress) {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.CITIZEN) revert WrongNotaryGrade();

        if (arbanRegistry == address(0) || citizenRegistry == address(0) || newLeaderCitizenAccount == address(0)) {
            revert ZeroAddress();
        }
        if (arbanId == 0) revert InvalidCount();
        if (minSignatures < 2 || minSignatures > 10) revert InvalidCount();

        ArbanLeaderAppointment doc = new ArbanLeaderAppointment(
            arbanRegistry,
            citizenRegistry,
            arbanId,
            newLeaderCitizenAccount,
            minSignatures,
            docHash
        );

        docAddress = address(doc);

        // allow this document to apply changes in ArbanRegistry on finalize()
        IArbanRegistryUpdaters(arbanRegistry).setUpdater(docAddress, true);

        docId = docRegistry.issue(
            DocumentRegistry.Grade.CITIZEN,
            arbanId,
            docHash,
            msg.sender,
            docAddress
        );

        emit ArbanLeaderAppointmentIssued(
            docId,
            arbanId,
            docAddress,
            newLeaderCitizenAccount,
            minSignatures,
            docHash
        );
    }

    /* =========================================================
       ZUN: RESOLUTION + LEADER APPOINTMENT
       ========================================================= */

    function issueZunResolution(uint256 zunId, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.ZUN) revert WrongNotaryGrade();

        ZunResolution doc = new ZunResolution(structureRegistry, zunId, docHash, msg.sender);
        docAddress = address(doc);

        docId = docRegistry.issue(DocumentRegistry.Grade.ZUN, zunId, docHash, msg.sender, docAddress);
        emit ZunDocumentIssued(docId, zunId, docAddress, docHash);
    }

    function issueZunLeaderAppointment(uint256 zunId, address newLeader, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.ZUN) revert WrongNotaryGrade();
        if (newLeader == address(0)) revert ZeroAddress();

        ZunLeaderAppointment doc = new ZunLeaderAppointment(structureRegistry, zunId, newLeader, docHash, msg.sender);
        docAddress = address(doc);

        IStructureRegistryUpdaters(structureRegistry).setUpdater(docAddress, true);

        docId = docRegistry.issue(DocumentRegistry.Grade.ZUN, zunId, docHash, msg.sender, docAddress);
        emit ZunLeaderAppointmentIssued(docId, zunId, docAddress, newLeader, docHash);
    }

    /* =========================================================
       MYANGAN: RESOLUTION + LEADER APPOINTMENT
       ========================================================= */

    function issueMyanganResolution(uint256 myanganId, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.MYANGAN) revert WrongNotaryGrade();

        MyanganResolution doc = new MyanganResolution(structureRegistry, myanganId, docHash, msg.sender);
        docAddress = address(doc);

        docId = docRegistry.issue(DocumentRegistry.Grade.MYANGAN, myanganId, docHash, msg.sender, docAddress);
        emit MyanganDocumentIssued(docId, myanganId, docAddress, docHash);
    }

    function issueMyanganLeaderAppointment(uint256 myanganId, address newLeader, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.MYANGAN) revert WrongNotaryGrade();
        if (newLeader == address(0)) revert ZeroAddress();

        MyanganLeaderAppointment doc = new MyanganLeaderAppointment(
            structureRegistry,
            myanganId,
            newLeader,
            docHash,
            msg.sender
        );
        docAddress = address(doc);

        IStructureRegistryUpdaters(structureRegistry).setUpdater(docAddress, true);

        docId = docRegistry.issue(DocumentRegistry.Grade.MYANGAN, myanganId, docHash, msg.sender, docAddress);
        emit MyanganLeaderAppointmentIssued(docId, myanganId, docAddress, newLeader, docHash);
    }

    /* =========================================================
       TUMEN: RESOLUTION + LEADER APPOINTMENT
       ========================================================= */

    function issueTumenResolution(uint256 tumenId, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.TUMEN) revert WrongNotaryGrade();

        TumenResolution doc = new TumenResolution(structureRegistry, tumenId, docHash, msg.sender);
        docAddress = address(doc);

        docId = docRegistry.issue(DocumentRegistry.Grade.TUMEN, tumenId, docHash, msg.sender, docAddress);
        emit TumenDocumentIssued(docId, tumenId, docAddress, docHash);
    }

    function issueTumenLeaderAppointment(uint256 tumenId, address newLeader, bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.TUMEN) revert WrongNotaryGrade();
        if (newLeader == address(0)) revert ZeroAddress();

        TumenLeaderAppointment doc = new TumenLeaderAppointment(
            structureRegistry,
            tumenId,
            newLeader,
            docHash,
            msg.sender
        );
        docAddress = address(doc);

        IStructureRegistryUpdaters(structureRegistry).setUpdater(docAddress, true);

        docId = docRegistry.issue(DocumentRegistry.Grade.TUMEN, tumenId, docHash, msg.sender, docAddress);
        emit TumenLeaderAppointmentIssued(docId, tumenId, docAddress, newLeader, docHash);
    }

    /* =========================================================
       CHAIRMAN: RESOLUTION
       ========================================================= */

    function issueChairmanResolution(bytes32 docHash)
        external
        returns (uint256 docId, address docAddress)
    {
        if (!active[msg.sender]) revert NotActiveNotary();
        if (notaryGrade[msg.sender] != NotaryGrade.CHAIRMAN) revert WrongNotaryGrade();
        if (chairmanRegistry == address(0)) revert ChairmanRegistryNotSet();

        ChairmanResolution doc = new ChairmanResolution(chairmanRegistry, docHash, msg.sender);
        docAddress = address(doc);

        docId = docRegistry.issue(
            DocumentRegistry.Grade.CHAIRMAN,
            0,
            docHash,
            msg.sender,
            docAddress
        );

        emit ChairmanDocumentIssued(docId, docAddress, docHash);
    }
}
