await tx.wait();
    }
  }

  // -----------------------------
  // 2) Create CitizenAccount for each seat
  // createCitizen(seatId, controller)
  // -----------------------------
  for (let i = 0; i < seatIds.length; i++) {
    const seatId = seatIds[i];
    const controller = controllers[i];

    const existing = await citizenRegistry.citizenOfSeat(seatId);
    if (existing === ethers.ZeroAddress) {
      const tx = await citizenRegistry.connect(controller).createCitizen(seatId, controller.address);
      await tx.wait();
    }
  }

  // -----------------------------
  // 3) Issue ArbanJoinDoc via NotaryHub
  // NotaryHub.issueArbanJoinDoc(
  //   arbanRegistry, citizenRegistry, arbanId, leaderCitizenAccount, seatIds, minSignatures, docHash
  // )
  // -----------------------------
  const arbanId = 1;

  const leaderSeatId = seatIds[0];
  const leaderCitizen = await citizenRegistry.citizenOfSeat(leaderSeatId);
  if (leaderCitizen === ethers.ZeroAddress) throw new Error("Leader citizen is zero");

  const minSignatures = seatIds.length; // require all for smoke
  const docHash = ethers.keccak256(ethers.toUtf8Bytes(`ARBAJOIN:${Date.now()}`));

  const issueTx = await notaryHub.connect(deployer).issueArbanJoinDoc(
    ARBAN_REGISTRY,
    CITIZEN_REGISTRY,
    arbanId,
    leaderCitizen,
    seatIds,
    minSignatures,
    docHash
  );
  const rc = await issueTx.wait();

  // Find docAddress from event ArbanJoinDocIssued(docId, arbanId, docAddress, leader, minSignatures, docHash)
  let docAddress = null;
  for (const log of rc.logs) {
    try {
      const parsed = notaryHub.interface.parseLog(log);
      if (parsed && parsed.name === "ArbanJoinDocIssued") {
        docAddress = parsed.args.docAddress;
        break;
      }
    } catch (_) {}
  }
  if (!docAddress) throw new Error("Cannot parse ArbanJoinDocIssued event to get docAddress");

  const joinDoc = await ethers.getContractAt("ArbanJoinDoc", docAddress);

  // -----------------------------
  // 4) Each CitizenAccount calls join(seatId) via execute()
  // join(seatId) requires msg.sender == citizenRegistry.citizenOfSeat(seatId)
  // so we must call from CitizenAccount itself.
  // -----------------------------
  for (let i = 0; i < seatIds.length; i++) {
    const seatId = seatIds[i];
    const controller = controllers[i];

    const citizenAccountAddr = await citizenRegistry.citizenOfSeat(seatId);
    const citizenAccount = await ethers.getContractAt("CitizenAccount", citizenAccountAddr);

    const calldata = joinDoc.interface.encodeFunctionData("join", [seatId]);
    const tx = await citizenAccount.connect(controller).execute(docAddress, 0, calldata);
    await tx.wait();
  }

  // -----------------------------
  // 5) finalize
  // -----------------------------
  const finTx = await joinDoc.connect(deployer).finalize();
  await finTx.wait();

  // -----------------------------
  // 6) checks
  // -----------------------------
  const members = await arbanRegistry.getMembers(arbanId);
  const leaderOnChain = await arbanRegistry.leaderOfArban(arbanId);

  // members contains seatIds
  const have = members.map((x) => BigInt(x));
  const want = seatIds.map((x) => BigInt(x));
  for (const x of want) {
    if (!have.includes(x)) throw new Error(`Missing seatId in members: ${x}`);
  }

  if (leaderOnChain.toLowerCase() !== leaderCitizen.toLowerCase()) {
    throw new Error(`Leader mismatch: got=${leaderOnChain} want=${leaderCitizen}`);
  }

  console.log("OK: Citizen → ArbanJoinDoc.join() via CitizenAccount.execute() → finalize()");
  console.log({ arbanId, docAddress, leaderCitizen, membersCount: members.length });
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
