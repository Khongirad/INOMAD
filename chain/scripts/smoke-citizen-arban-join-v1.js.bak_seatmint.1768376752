const hre = require("hardhat");
const { ethers } = hre;

function mustAddr(name, v) {
  if (typeof v !== "string" || !/^0x[a-fA-F0-9]{40}$/.test(v)) {
    throw new Error(`Invalid ${name} address: '${v}'. Provide a real 0x... address (42 chars).`);
  }
  return v;
}

async function tryOwnerOf(seatSBT, seatId) {
  try {
    return await seatSBT.ownerOf(seatId);
  } catch (e) {
    return null;
  }
}

async function pickExistingSeatIds(seatSBT, wantN) {
  const picked = [];
  for (let id = 1; id <= 500 && picked.length < wantN; id++) {
    const o = await tryOwnerOf(seatSBT, id);
    if (o) picked.push(id);
  }
  if (picked.length < wantN) {
    throw new Error(`Not enough existing SeatSBT tokens. Found ${picked.length}, need ${wantN}. Mint seats first or adjust scan range.`);
  }
  return picked.slice(0, wantN);
}

async function main() {
  const SEAT_SBT = mustAddr("SEAT_SBT", process.env.SEAT_SBT);
  const CITIZEN_REGISTRY = mustAddr("CITIZEN_REGISTRY", process.env.CITIZEN_REGISTRY);
  const ARBAN_REGISTRY = mustAddr("ARBAN_REGISTRY", process.env.ARBAN_REGISTRY);
  const NOTARY_HUB = mustAddr("NOTARY_HUB", process.env.NOTARY_HUB);

  const signers = await ethers.getSigners();
  const [deployer] = signers;

  const seatSBT = await ethers.getContractAt("SeatSBT", SEAT_SBT);
  const citizenRegistry = await ethers.getContractAt("CitizenRegistry", CITIZEN_REGISTRY);
  const arbanRegistry = await ethers.getContractAt("ArbanRegistry", ARBAN_REGISTRY);
  const notaryHub = await ethers.getContractAt("NotaryHub", NOTARY_HUB);

  // 1) Choose 10 existing seats
  const seatIds = await pickExistingSeatIds(seatSBT, 10);

  // 2) Create CitizenAccounts for each seatId (controller = EOA owner of seat)
  // CitizenRegistry.createCitizen(seatId, controller)
  for (const seatId of seatIds) {
    const owner = await seatSBT.ownerOf(seatId);
    const signer = signers.find(s => s.address.toLowerCase() === owner.toLowerCase()) || deployer;

    // if already exists, skip
    const existing = await citizenRegistry.citizenOfSeat(seatId);
    if (existing && existing !== ethers.ZeroAddress) continue;

    const tx = await citizenRegistry.connect(signer).createCitizen(seatId, owner);
    await tx.wait();
  }

  // 3) leader = citizen account of first seatId
  const leaderSeatId = seatIds[0];
  const leaderCitizen = await citizenRegistry.citizenOfSeat(leaderSeatId);
  if (!leaderCitizen || leaderCitizen === ethers.ZeroAddress) throw new Error("Leader citizen account not created");

  // 4) Issue ArbanJoinDoc via NotaryHub
  const arbanId = 1;                 // MVP: use arbanId=1
  const minSignatures = 2;           // MVP
  const docHash = ethers.keccak256(ethers.toUtf8Bytes("ARBAN_JOIN_DOC:v1"));

  const issueTx = await notaryHub.connect(deployer).issueArbanJoinDoc(
    ARBAN_REGISTRY,
    SEAT_SBT,
    arbanId,
    leaderCitizen,
    seatIds,
    minSignatures,
    docHash
  );
  const issueRc = await issueTx.wait();

  // NotaryHub emits ArbanJoinDocIssued(docId, arbanId, docAddress, leader, minSignatures, docHash)
  const evt = issueRc.logs
    .map(l => { try { return notaryHub.interface.parseLog(l); } catch { return null; } })
    .find(e => e && e.name === "ArbanJoinDocIssued");

  if (!evt) throw new Error("ArbanJoinDocIssued event not found");
  const docAddress = evt.args.docAddress;
  console.log("ArbanJoinDoc:", docAddress);

  const doc = await ethers.getContractAt("ArbanJoinDoc", docAddress);

  // 5) Join signatures via CitizenAccount.execute(doc.join(seatId))
  const SeatAccount = await ethers.getContractFactory("SeatAccount"); // for interface only
  const seatAccountIface = SeatAccount.interface;

  for (const seatId of seatIds.slice(0, minSignatures)) {
    const citizenAcc = await citizenRegistry.citizenOfSeat(seatId);
    if (!citizenAcc || citizenAcc === ethers.ZeroAddress) throw new Error(`No citizen for seatId=${seatId}`);

    const owner = await seatSBT.ownerOf(seatId);
    const signer = signers.find(s => s.address.toLowerCase() === owner.toLowerCase()) || deployer;

    const joinCalldata = doc.interface.encodeFunctionData("join", [seatId]);

    // CitizenAccount.execute(to, value, data)
    const citizen = await ethers.getContractAt("SeatAccount", citizenAcc);
    const tx = await citizen.connect(signer).execute(docAddress, 0, joinCalldata);
    await tx.wait();

    console.log("Joined seatId", seatId, "via", citizenAcc);
  }

  // 6) finalize
  const finTx = await doc.connect(deployer).finalize();
  await finTx.wait();
  console.log("Finalized");

  // 7) basic checks
  const leaderOnChain = await arbanRegistry.leaderOfArban(arbanId);
  console.log("leaderOfArban:", leaderOnChain);

  // try getMembers if exists
  try {
    const members = await arbanRegistry.getMembers(arbanId);
    console.log("members:", members.map(x => Number(x)));
  } catch (e) {
    // ignore if method differs
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
