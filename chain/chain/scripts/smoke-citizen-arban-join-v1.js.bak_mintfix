const { ethers } = require("hardhat");

async function main() {
  const [deployer, ...rest] = await ethers.getSigners();
  const controllers = rest.slice(0, 10);

  // -----------------------------
  // Load deployed addresses
  // -----------------------------
  const SEAT_SBT = process.env.SEAT_SBT;
  const CITIZEN_REGISTRY = process.env.CITIZEN_REGISTRY;
  const ARBAN_REGISTRY = process.env.ARBAN_REGISTRY;
  const NOTARY_HUB = process.env.NOTARY_HUB;


  // Validate env addresses (prevents ethers resolveName crash on placeholders like 0x...)
  const must = { SEAT_SBT, CITIZEN_REGISTRY, ARBAN_REGISTRY, NOTARY_HUB };
  for (const [k,v] of Object.entries(must)) {
    if (!v || !ethers.isAddress(v)) {
      throw new Error(`Invalid ${k} address: '${v}'. Provide a real 0x... address (42 chars).`);
    }
  }


  if (!SEAT_SBT || !CITIZEN_REGISTRY || !ARBAN_REGISTRY || !NOTARY_HUB) {
    throw new Error("Set env vars: SEAT_SBT, CITIZEN_REGISTRY, ARBAN_REGISTRY, NOTARY_HUB");
  }

  const seatSBT = await ethers.getContractAt("SeatSBT", SEAT_SBT);
  const citizenRegistry = await ethers.getContractAt("CitizenRegistry", CITIZEN_REGISTRY);
  const arbanRegistry = await ethers.getContractAt("ArbanRegistry", ARBAN_REGISTRY);
  const notaryHub = await ethers.getContractAt("NotaryHub", NOTARY_HUB);

  // -----------------------------
  // 1) Mint seatIds 2..10 (9 seats)
  // -----------------------------
  const seatIds = [];
  for (let i = 2; i <= 10; i++) seatIds.push(i);

  for (let i = 0; i < seatIds.length; i++) {
    const seatId = seatIds[i];
    const to = controllers[i].address;

    let minted = false;
    try {
      const owner = await seatSBT.ownerOf(seatId);
      if (owner && owner !== ethers.ZeroAddress) minted = true;
    } catch (_) {}

    if (!minted) {
      // IMPORTANT: adjust if your mint signature differs
      const tx = await seatSBT.connect(deployer).mint(to, seatId);
      await tx.wait();
    }
  }

  // -----------------------------
  // 2) Create CitizenAccount for each seat
  // createCitizen(seatId, controller)
  // -----------------------------
  for (let i = 0; i < seatIds.length; i++) {
    const seatId = seatIds[i];
    const controller = controllers[i];

    const existing = await citizenRegistry.citizenOfSeat(seatId);
    if (existing === ethers.ZeroAddress) {
      const tx = await citizenRegistry.connect(controller).createCitizen(seatId, controller.address);
      await tx.wait();
    }
  }

  // -----------------------------
  // 3) Issue ArbanJoinDoc via NotaryHub
  // NotaryHub.issueArbanJoinDoc(
  //   arbanRegistry, citizenRegistry, arbanId, leaderCitizenAccount, seatIds, minSignatures, docHash
  // )
  // -----------------------------
  const arbanId = 1;

  const leaderSeatId = seatIds[0];
  const leaderCitizen = await citizenRegistry.citizenOfSeat(leaderSeatId);
  if (leaderCitizen === ethers.ZeroAddress) throw new Error("Leader citizen is zero");

  const minSignatures = seatIds.length; // require all for smoke
  const docHash = ethers.keccak256(ethers.toUtf8Bytes(`ARBAJOIN:${Date.now()}`));

  const issueTx = await notaryHub.connect(deployer).issueArbanJoinDoc(
    ARBAN_REGISTRY,
    CITIZEN_REGISTRY,
    arbanId,
    leaderCitizen,
    seatIds,
    minSignatures,
    docHash
  );
  const rc = await issueTx.wait();

  // Find docAddress from event ArbanJoinDocIssued(docId, arbanId, docAddress, leader, minSignatures, docHash)
  let docAddress = null;
  for (const log of rc.logs) {
    try {
      const parsed = notaryHub.interface.parseLog(log);
      if (parsed && parsed.name === "ArbanJoinDocIssued") {
        docAddress = parsed.args.docAddress;
        break;
      }
    } catch (_) {}
  }
  if (!docAddress) throw new Error("Cannot parse ArbanJoinDocIssued event to get docAddress");

  const joinDoc = await ethers.getContractAt("ArbanJoinDoc", docAddress);

  // -----------------------------
  // 4) Each CitizenAccount calls join(seatId) via execute()
  // join(seatId) requires msg.sender == citizenRegistry.citizenOfSeat(seatId)
  // so we must call from CitizenAccount itself.
  // -----------------------------
  for (let i = 0; i < seatIds.length; i++) {
    const seatId = seatIds[i];
    const controller = controllers[i];

    const citizenAccountAddr = await citizenRegistry.citizenOfSeat(seatId);
    const citizenAccount = await ethers.getContractAt("CitizenAccount", citizenAccountAddr);

    const calldata = joinDoc.interface.encodeFunctionData("join", [seatId]);
    const tx = await citizenAccount.connect(controller).execute(docAddress, 0, calldata);
    await tx.wait();
  }

  // -----------------------------
  // 5) finalize
  // -----------------------------
  const finTx = await joinDoc.connect(deployer).finalize();
  await finTx.wait();

  // -----------------------------
  // 6) checks
  // -----------------------------
  const members = await arbanRegistry.getMembers(arbanId);
  const leaderOnChain = await arbanRegistry.leaderOfArban(arbanId);

  // members contains seatIds
  const have = members.map((x) => BigInt(x));
  const want = seatIds.map((x) => BigInt(x));
  for (const x of want) {
    if (!have.includes(x)) throw new Error(`Missing seatId in members: ${x}`);
  }

  if (leaderOnChain.toLowerCase() !== leaderCitizen.toLowerCase()) {
    throw new Error(`Leader mismatch: got=${leaderOnChain} want=${leaderCitizen}`);
  }

  console.log("OK: Citizen → ArbanJoinDoc.join() via CitizenAccount.execute() → finalize()");
  console.log({ arbanId, docAddress, leaderCitizen, membersCount: members.length });
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
