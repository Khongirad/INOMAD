const fs = require("fs");
const path = require("path");
const { ethers } = require("hardhat");

async function main() {
  const signers = await ethers.getSigners();
  const [deployer, notaryZun, notaryMy, notaryTu, ...rest] = signers;

  // Deploy StructureRegistry
  const StructureRegistry = await ethers.getContractFactory(
    "StructureRegistry"
  );
  const registry = await StructureRegistry.deploy(ethers.ZeroAddress);
  await registry.waitForDeployment();
  // --- SeatSBT + SeatAccountFactory + CitizenRegistry + ArbanRegistry ---
  const SeatSBT = await ethers.getContractFactory("SeatSBT");
  const seat = await SeatSBT.deploy();
  await seat.waitForDeployment();

  const SeatAccountFactory = await ethers.getContractFactory("SeatAccountFactory");
  const factory = await SeatAccountFactory.deploy(await seat.getAddress());
await factory.waitForDeployment();

  const CitizenRegistry = await ethers.getContractFactory("CitizenRegistry");
  const citizen = await CitizenRegistry.deploy(await seat.getAddress());
await citizen.waitForDeployment();

// --- OrganizationFactory + Organization (needed for ArbanRegistry ctor) ---
const OrganizationFactory = await ethers.getContractFactory("OrganizationFactory");
const orgFactory = await OrganizationFactory.deploy(await seat.getAddress());
await orgFactory.waitForDeployment();

const txOrg = await orgFactory.createOrganizationWithArban(
  0, // OrgType.PRIVATE
  0, // Branch.NONE
  ethers.ZeroAddress, // notary
  ethers.ZeroAddress  // archivist
);
const rcOrg = await txOrg.wait();

let organizationAddr = null;
for (const log of rcOrg.logs) {{
  try {{
    const parsed = orgFactory.interface.parseLog(log);
    if (parsed && (parsed.name === "OrganizationCreated" || parsed.name === "OrganizationRegistered")) {{
      organizationAddr = parsed.args.organization || parsed.args.org || parsed.args.organizationAddr || null;
    }}
  }} catch (e) {{}}
}}

if (!organizationAddr) {{
  try {{
    organizationAddr = await orgFactory.organizations(1);
  }} catch (e) {{}}
}}

if (!organizationAddr) throw new Error("Cannot detect organization address");

  const ArbanRegistry = await ethers.getContractFactory("ArbanRegistry");
  const arban = await ArbanRegistry.deploy(organizationAddr, await seat.getAddress(), await registry.getAddress());
await arban.waitForDeployment();

  const registryAddr = await registry.getAddress();

  // Create 10 Zun -> 1 Myangan -> (need 10 Myangan for Tumen, but for smoke we’ll create 10 Myangan)
  const leader = deployer.address;

  const myanganIds = [];

  for (let m = 0; m < 10; m++) {
    const zunIds = [];

    for (let z = 0; z < 10; z++) {
      const base = m * 100 + z * 10 + 1;
      const arbanIds = [
        base,
        base + 1,
        base + 2,
        base + 3,
        base + 4,
        base + 5,
        base + 6,
        base + 7,
        base + 8,
        base + 9,
      ];

      const txZ = await registry.registerZun(arbanIds, leader);
      const rcZ = await txZ.wait();
      const evtZ = rcZ.logs
        .map((l) => {
          try {
            return registry.interface.parseLog(l);
          } catch {
            return null;
          }
        })
        .find((e) => e && e.name === "ZunRegistered");
      const zunId = Number(evtZ.args.zunId);
      zunIds.push(zunId);

      // лидеры Arbans для Zun-доков (10 лидеров)
      for (let i = 0; i < 10; i++) {
        await (
          await registry.setArbanLeader(
            arbanIds[i],
            rest[(m * 100 + z * 10 + i) % rest.length].address
          )
        ).wait();
      }

      // лидер самого Zun (для Myangan-доков)
      await (
        await registry.setZunLeaderCitizen(
          zunId,
          rest[(m * 10 + z) % rest.length].address
        )
      ).wait();
    }

    const txM = await registry.registerMyangan(zunIds, leader);
    const rcM = await txM.wait();
    const evtM = rcM.logs
      .map((l) => {
        try {
          return registry.interface.parseLog(l);
        } catch {
          return null;
        }
      })
      .find((e) => e && e.name === "MyanganRegistered");

    const myanganId = Number(evtM.args.myanganId);
    myanganIds.push(myanganId);

    // лидер Myangan (для Tumen-доков)
    await (
      await registry.setMyanganLeaderCitizen(
        myanganId,
        rest[m % rest.length].address
      )
    ).wait();
  }

  // Create Tumen from 10 Myangan
  const txT = await registry.registerTumen(myanganIds, leader);
  const rcT = await txT.wait();
  const evtT = rcT.logs
    .map((l) => {
      try {
        return registry.interface.parseLog(l);
      } catch {
        return null;
      }
    })
    .find((e) => e && e.name === "TumenRegistered");

  const tumenId = Number(evtT.args.tumenId);
  await (await registry.setTumenLeaderCitizen(tumenId, rest[0].address)).wait();

  // Deploy DocumentRegistry + NotaryHub
  const DocumentRegistry = await ethers.getContractFactory("DocumentRegistry");
  const docReg = await DocumentRegistry.deploy();
  await docReg.waitForDeployment();


  const ChairmanRegistry = await ethers.getContractFactory("ChairmanRegistry");
  const chairReg = await ChairmanRegistry.deploy();
  await chairReg.waitForDeployment();

  const NotaryHub = await ethers.getContractFactory("NotaryHub");
  const hub = await NotaryHub.deploy(registryAddr, await docReg.getAddress(), await chairReg.getAddress());
  await hub.waitForDeployment();

  


  // --- Deploy SeatSBT + CitizenRegistry stack in THIS scope (for addresses-stack.json) ---
  const SeatSBT2 = await ethers.getContractFactory("SeatSBT");
  const seat2 = await SeatSBT.deploy();
  await seat2.waitForDeployment();

  const SeatAccountFactory2 = await ethers.getContractFactory("SeatAccountFactory");
  const factory2 = await SeatAccountFactory.deploy(await seat2.getAddress());
  await factory2.waitForDeployment();

  const CitizenRegistry2 = await ethers.getContractFactory("CitizenRegistry");
  const citizen2 = await CitizenRegistry.deploy(await seat2.getAddress());
  await citizen2.waitForDeployment();

  // OrganizationFactory -> create org (needed by ArbanRegistry ctor: (organization, seatSbt, structureRegistry))
  const OrganizationFactory2 = await ethers.getContractFactory("OrganizationFactory");
  const orgFactory2 = await OrganizationFactory.deploy(await seat2.getAddress());
  await orgFactory2.waitForDeployment();

  const txOrg = await orgFactory2.createOrganizationWithArban(
    0, // OrgType.PRIVATE
    0, // Branch.NONE
    ethers.ZeroAddress, // notary
    ethers.ZeroAddress  // archivist
  );
  const rcOrg = await txOrg.wait();

  let organizationAddr2 = null;
  for (const log of rcOrg.logs) {
    try {
      const parsed = orgFactory2.interface.parseLog(log);
      if (parsed && (parsed.name === "OrganizationCreated" || parsed.name === "OrganizationRegistered")) {
        organizationAddr2 = parsed.args.organization || parsed.args.org || parsed.args.organizationAddr || null;
      }
    } catch (e) {}
  }
  if (!organizationAddr2) {
    try { organizationAddr2 = await orgFactory.organizations(1); } catch (e) {}
  }
  if (!organizationAddr2) throw new Error("Cannot detect organization address from createOrganizationWithArban()");

  const ArbanRegistry2 = await ethers.getContractFactory("ArbanRegistry");
  const arban2 = await ArbanRegistry2.deploy(organizationAddr2, await seat2.getAddress(), registryAddr);
  await arban2.waitForDeployment();

    // --- PRINT STACK ADDRESSES (safe) ---
        const stackOut = {
          SeatSBT: await seat2.getAddress(),
          SeatAccountFactory: await factory2.getAddress(),
          CitizenRegistry: await citizen2.getAddress(),
          OrganizationFactory: await orgFactory2.getAddress(),
          Organization: organizationAddr2,
          ArbanRegistry: await arban2.getAddress(),
          StructureRegistry: registryAddr,
          DocumentRegistry: await docReg.getAddress(),
          ChairmanRegistry: await chairReg.getAddress(),
          NotaryHub: await hub.getAddress(),
        };

        // add optional addresses only if variables exist in this scope
        try { if (typeof seat !== "undefined") stackOut.SeatSBT = await seat2.getAddress(); } catch(e) {}
        try { if (typeof citizen !== "undefined") stackOut.CitizenRegistry = await citizen2.getAddress(); } catch(e) {}
        try { if (typeof orgFactory !== "undefined") stackOut.OrganizationFactory = await orgFactory2.getAddress(); } catch(e) {}
        try { if (typeof organizationAddr !== "undefined" && organizationAddr) stackOut.Organization = organizationAddr; } catch(e) {}
        try { if (typeof arban !== "undefined") stackOut.ArbanRegistry = await arban2.getAddress(); } catch(e) {}

        const outPath = path.join(process.cwd(), "addresses-stack.json");
        fs.writeFileSync(outPath, JSON.stringify(stackOut, null, 2));
        console.log("STACK_ADDRESSES_JSON:", outPath);
        for (const [k,v] of Object.entries(stackOut)) console.log(`${k}: ${v}`);
// make hub owner of docReg
  await (await docReg.setOwner(await hub.getAddress())).wait();

  // set notaries
  await (await hub.setNotary(notaryZun.address, 2, true)).wait(); // ZUN
  await (await hub.setNotary(notaryMy.address, 3, true)).wait(); // MYANGAN
  await (await hub.setNotary(notaryTu.address, 4, true)).wait(); // TUMEN

  // Issue Myangan doc
  const hashMy = ethers.keccak256(ethers.toUtf8Bytes("MYANGAN:doc:v1"));
  const issuedMy = await (
    await hub.connect(notaryMy).issueMyanganResolution(1, hashMy)
  ).wait();
  console.log("Issued Myangan doc (id=1) OK");

  // Issue Tumen doc
  const hashTu = ethers.keccak256(ethers.toUtf8Bytes("TUMEN:doc:v1"));
  const issuedTu = await (
    await hub.connect(notaryTu).issueTumenResolution(tumenId, hashTu)
  ).wait();
  console.log("Issued Tumen doc OK");

  console.log("Done.");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
